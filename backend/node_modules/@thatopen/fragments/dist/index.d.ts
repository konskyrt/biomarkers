import * as flatbuffers from 'flatbuffers';
import { LineMaterial } from 'three/examples/jsm/Addons.js';
import { LineMaterialParameters } from 'three/examples/jsm/lines/LineMaterial.js';
import { Sample } from './sample.js';
import * as THREE from 'three';

export declare class Alignment {
    bb: flatbuffers.ByteBuffer | null;
    bb_pos: number;
    __init(i: number, bb: flatbuffers.ByteBuffer): Alignment;
    static getRootAsAlignment(bb: flatbuffers.ByteBuffer, obj?: Alignment): Alignment;
    static getSizePrefixedRootAsAlignment(bb: flatbuffers.ByteBuffer, obj?: Alignment): Alignment;
    absolute(index: number): number | null;
    absoluteLength(): number;
    absoluteArray(): Uint32Array | null;
    static startAlignment(builder: flatbuffers.Builder): void;
    static addAbsolute(builder: flatbuffers.Builder, absoluteOffset: flatbuffers.Offset): void;
    static createAbsoluteVector(builder: flatbuffers.Builder, data: number[] | Uint32Array): flatbuffers.Offset;
    /**
     * @deprecated This Uint8Array overload will be removed in the future.
     */
    static createAbsoluteVector(builder: flatbuffers.Builder, data: number[] | Uint8Array): flatbuffers.Offset;
    static startAbsoluteVector(builder: flatbuffers.Builder, numElems: number): void;
    static endAlignment(builder: flatbuffers.Builder): flatbuffers.Offset;
    static createAlignment(builder: flatbuffers.Builder, absoluteOffset: flatbuffers.Offset): flatbuffers.Offset;
}

export declare type AlignmentCurve = {
    points: Float32Array;
    type: GeometryClass;
};

export declare type AlignmentData = {
    absolute: AlignmentCurve[];
};

/**
 * Represents an alignment in a civil engineering project. An alignment consists of vertical, horizontal, and absolute civil curves.
 */
export declare class AlignmentObject {
    /**
     * Vertical civil curves in the alignment.
     */
    vertical: CivilCurve[];
    /**
     * Horizontal civil curves in the alignment.
     */
    horizontal: CivilCurve[];
    /**
     * Absolute civil curves in the alignment.
     */
    absolute: CivilCurve[];
    /**
     * Initial KP (Kilometer Point) of the alignment.
     */
    initialKP: number;
    /**
     * Returns the total length of the specified alignment type.
     * @param type - The type of alignment (vertical, horizontal, or absolute).
     * @returns The total length of the specified alignment type.
     */
    getLength(type: AlignmentType): number;
    /**
     * Returns the point at the specified percentage along the specified alignment type.
     * @param percentage - The percentage along the alignment type (between zero and one).
     * @param type - The type of alignment (vertical, horizontal, or absolute).
     * @returns The point at the specified percentage along the specified alignment type.
     * @throws Will throw an error if the percentage is out of range or if the point cannot be computed.
     */
    getPointAt(percentage: number, type: AlignmentType): THREE.Vector3;
    getPercentageAt(point: THREE.Vector3, type: AlignmentType, tolerance?: number): number | null;
    /**
     * Returns the curve and the percentage at the specified percentage along the specified alignment type.
     * If the percentage is out of range, it will be clamped to the nearest valid value (0 or 1).
     * If the point cannot be computed, an error will be thrown.
     *
     * @param percentage - The percentage along the alignment type (between zero and one).
     * @param type - The type of alignment (vertical, horizontal, or absolute).
     * @returns An object containing the curve and the percentage along the curve.
     * @throws Will throw an error if the percentage is out of range or if the point cannot be computed.
     */
    getCurveAt(percentage: number, type: AlignmentType): {
        curve: CivilCurve;
        percentage: number;
    };
}

/**
 * Represents the type of alignment, which can be vertical, horizontal, or absolute.
 */
export declare type AlignmentType = "vertical" | "horizontal" | "absolute";

export declare class AsyncEvent<T> {
    enabled: boolean;
    add(handler: T extends void ? {
        (): Promise<void>;
    } : {
        (data: T): Promise<void>;
    }): void;
    remove(handler: T extends void ? {
        (): Promise<void>;
    } : {
        (data: T): Promise<void>;
    }): void;
    trigger: (data?: T) => Promise<void>;
    reset(): void;
    private handlers;
}

export declare class Attribute {
    bb: flatbuffers.ByteBuffer | null;
    bb_pos: number;
    __init(i: number, bb: flatbuffers.ByteBuffer): Attribute;
    static getRootAsAttribute(bb: flatbuffers.ByteBuffer, obj?: Attribute): Attribute;
    static getSizePrefixedRootAsAttribute(bb: flatbuffers.ByteBuffer, obj?: Attribute): Attribute;
    data(index: number): string;
    data(index: number, optionalEncoding: flatbuffers.Encoding): string | Uint8Array;
    dataLength(): number;
    static startAttribute(builder: flatbuffers.Builder): void;
    static addData(builder: flatbuffers.Builder, dataOffset: flatbuffers.Offset): void;
    static createDataVector(builder: flatbuffers.Builder, data: flatbuffers.Offset[]): flatbuffers.Offset;
    static startDataVector(builder: flatbuffers.Builder, numElems: number): void;
    static endAttribute(builder: flatbuffers.Builder): flatbuffers.Offset;
    static createAttribute(builder: flatbuffers.Builder, dataOffset: flatbuffers.Offset): flatbuffers.Offset;
}

/**
 * Represents attribute data for a model item.
 */
export declare type AttributeData = {
    /** The value of the attribute, which can be any type */
    value: any;
    /** Optional type identifier for the attribute value */
    type?: number;
};

/**
 * Interface representing the attributes of a model item.
 */
export declare interface Attributes {
    /** Unique local identifier for the item */
    localId: number;
    /** Optional category identifier */
    category?: number;
    /** Optional globally unique identifier */
    guid?: string;
    /** Additional arbitrary attributes can be added with any name and value */
    [name: string]: any;
}

/**
 * Interface representing a change event when attributes are added to a model item.
 */
declare interface AttrsAddChange {
    /** Indicates this is an "added" type change */
    type: "added";
    /** Record containing the newly added attribute data */
    data: Record<string, any>;
}

/**
 * Union type representing all possible attribute change types.
 */
export declare type AttrsChange = AttrsDeleteChange | AttrsModifyChange | AttrsAddChange;

/**
 * Interface representing a change event when attributes are deleted from a model item.
 */
declare interface AttrsDeleteChange {
    /** Indicates this is a "deleted" type change */
    type: "deleted";
}

/**
 * Interface representing a change event when attributes are modified in a model item.
 */
declare interface AttrsModifyChange {
    /** Indicates this is a "modified" type change */
    type: "modified";
    /** Record containing the newly added attribute data */
    added: Record<string, any>;
    /** Array of strings representing the deleted attribute keys */
    deleted: string[];
    /** Record containing the modified attribute data */
    modified: Record<string, any>;
}

export declare class Axis {
    bb: flatbuffers.ByteBuffer | null;
    bb_pos: number;
    __init(i: number, bb: flatbuffers.ByteBuffer): Axis;
    static getRootAsAxis(bb: flatbuffers.ByteBuffer, obj?: Axis): Axis;
    static getSizePrefixedRootAsAxis(bb: flatbuffers.ByteBuffer, obj?: Axis): Axis;
    wires(index: number, obj?: Wire): Wire | null;
    wiresLength(): number;
    order(index: number): number | null;
    orderLength(): number;
    orderArray(): Uint32Array | null;
    parts(index: number): AxisPartClass | null;
    partsLength(): number;
    partsArray(): Int8Array | null;
    wireSets(index: number, obj?: WireSet): WireSet | null;
    wireSetsLength(): number;
    circleCurves(index: number, obj?: CircleCurve): CircleCurve | null;
    circleCurvesLength(): number;
    static startAxis(builder: flatbuffers.Builder): void;
    static addWires(builder: flatbuffers.Builder, wiresOffset: flatbuffers.Offset): void;
    static startWiresVector(builder: flatbuffers.Builder, numElems: number): void;
    static addOrder(builder: flatbuffers.Builder, orderOffset: flatbuffers.Offset): void;
    static createOrderVector(builder: flatbuffers.Builder, data: number[] | Uint32Array): flatbuffers.Offset;
    /**
     * @deprecated This Uint8Array overload will be removed in the future.
     */
    static createOrderVector(builder: flatbuffers.Builder, data: number[] | Uint8Array): flatbuffers.Offset;
    static startOrderVector(builder: flatbuffers.Builder, numElems: number): void;
    static addParts(builder: flatbuffers.Builder, partsOffset: flatbuffers.Offset): void;
    static createPartsVector(builder: flatbuffers.Builder, data: AxisPartClass[]): flatbuffers.Offset;
    static startPartsVector(builder: flatbuffers.Builder, numElems: number): void;
    static addWireSets(builder: flatbuffers.Builder, wireSetsOffset: flatbuffers.Offset): void;
    static createWireSetsVector(builder: flatbuffers.Builder, data: flatbuffers.Offset[]): flatbuffers.Offset;
    static startWireSetsVector(builder: flatbuffers.Builder, numElems: number): void;
    static addCircleCurves(builder: flatbuffers.Builder, circleCurvesOffset: flatbuffers.Offset): void;
    static startCircleCurvesVector(builder: flatbuffers.Builder, numElems: number): void;
    static endAxis(builder: flatbuffers.Builder): flatbuffers.Offset;
    static createAxis(builder: flatbuffers.Builder, wiresOffset: flatbuffers.Offset, orderOffset: flatbuffers.Offset, partsOffset: flatbuffers.Offset, wireSetsOffset: flatbuffers.Offset, circleCurvesOffset: flatbuffers.Offset): flatbuffers.Offset;
}

export declare enum AxisPartClass {
    NONE = 0,
    WIRE = 1,
    WIRE_SET = 2,
    CIRCLE_CURVE = 3
}

/**
 * Union type representing all possible material types.
 */
export declare type BIMMaterial = LodMaterial | THREE.MeshLambertMaterial;

/**
 * Union type representing all possible mesh types.
 */
export declare type BIMMesh = THREE.Mesh | LODMesh;

export declare class BoundingBox {
    bb: flatbuffers.ByteBuffer | null;
    bb_pos: number;
    __init(i: number, bb: flatbuffers.ByteBuffer): BoundingBox;
    min(obj?: FloatVector): FloatVector | null;
    max(obj?: FloatVector): FloatVector | null;
    static sizeOf(): number;
    static createBoundingBox(builder: flatbuffers.Builder, min_x: number, min_y: number, min_z: number, max_x: number, max_y: number, max_z: number): flatbuffers.Offset;
}

export declare class CircleCurve {
    bb: flatbuffers.ByteBuffer | null;
    bb_pos: number;
    __init(i: number, bb: flatbuffers.ByteBuffer): CircleCurve;
    aperture(): number;
    mutate_aperture(value: number): boolean;
    position(obj?: FloatVector): FloatVector | null;
    radius(): number;
    mutate_radius(value: number): boolean;
    xDirection(obj?: FloatVector): FloatVector | null;
    yDirection(obj?: FloatVector): FloatVector | null;
    static sizeOf(): number;
    static createCircleCurve(builder: flatbuffers.Builder, aperture: number, position_x: number, position_y: number, position_z: number, radius: number, x_direction_x: number, x_direction_y: number, x_direction_z: number, y_direction_x: number, y_direction_y: number, y_direction_z: number): flatbuffers.Offset;
}

export declare class CircleExtrusion {
    bb: flatbuffers.ByteBuffer | null;
    bb_pos: number;
    __init(i: number, bb: flatbuffers.ByteBuffer): CircleExtrusion;
    static getRootAsCircleExtrusion(bb: flatbuffers.ByteBuffer, obj?: CircleExtrusion): CircleExtrusion;
    static getSizePrefixedRootAsCircleExtrusion(bb: flatbuffers.ByteBuffer, obj?: CircleExtrusion): CircleExtrusion;
    radius(index: number): number | null;
    radiusLength(): number;
    radiusArray(): Float64Array | null;
    axes(index: number, obj?: Axis): Axis | null;
    axesLength(): number;
    static startCircleExtrusion(builder: flatbuffers.Builder): void;
    static addRadius(builder: flatbuffers.Builder, radiusOffset: flatbuffers.Offset): void;
    static createRadiusVector(builder: flatbuffers.Builder, data: number[] | Float64Array): flatbuffers.Offset;
    /**
     * @deprecated This Uint8Array overload will be removed in the future.
     */
    static createRadiusVector(builder: flatbuffers.Builder, data: number[] | Uint8Array): flatbuffers.Offset;
    static startRadiusVector(builder: flatbuffers.Builder, numElems: number): void;
    static addAxes(builder: flatbuffers.Builder, axesOffset: flatbuffers.Offset): void;
    static createAxesVector(builder: flatbuffers.Builder, data: flatbuffers.Offset[]): flatbuffers.Offset;
    static startAxesVector(builder: flatbuffers.Builder, numElems: number): void;
    static endCircleExtrusion(builder: flatbuffers.Builder): flatbuffers.Offset;
    static createCircleExtrusion(builder: flatbuffers.Builder, radiusOffset: flatbuffers.Offset, axesOffset: flatbuffers.Offset): flatbuffers.Offset;
}

/**
 * Represents an alignment curve of a civil engineering model.
 */
export declare class CivilCurve {
    /**
     * The index of the curve. An alignment is a sequence of ordered curves, and this is the index of this curve in that sequence.
     */
    index: number;
    /**
     * The THREE.js mesh containing the vertices of the curve.
     */
    mesh: CurveMesh;
    /**
     * Additional data associated with the curve.
     */
    data: {
        [name: string]: any;
    };
    /**
     * The alignment to which this curve belongs.
     */
    alignment: AlignmentObject;
    private get _index();
    private get _pos();
    /**
     * Constructs a new instance of CivilCurve.
     * @param index - The index of the curve.
     * @param mesh - The mesh associated with the curve.
     * @param data - Additional data associated with the curve.
     * @param alignment - The alignment of the curve.
     */
    constructor(index: number, mesh: CurveMesh, data: {
        [name: string]: any;
    }, alignment: AlignmentObject);
    /**
     * Calculates the total length of the curve by summing up the lengths of all segments.
     * @returns The total length of the curve.
     */
    getLength(): number;
    /**
     * Calculates a point on the curve based on the given percentage.
     *
     * @param percentage - The percentage along the curve (between zero and one).
     * @returns A new THREE.Vector3 representing the point on the curve.
     *
     * @remarks
     * The method works by first finding the segment that corresponds to the given percentage.
     * It then normalizes the direction of the segment, multiplies it by the distance to the start of the segment,
     * and adds it to the start point of the segment.
     *
     * @throws Will throw an error if the percentage is outside the range [0, 1].
     */
    getPointAt(percentage: number): THREE.Vector3;
    /**
     * Calculates a segment of the curve based on the given percentage.
     *
     * @param percentage - The percentage along the curve (between zero and one).
     * @returns An object containing the distance to the start of the segment, the index of the segment, and the start and end points of the segment.
     *
     * @remarks
     * The method works by first finding the segment that corresponds to the given percentage.
     * It then returns an object containing the distance to the start of the segment, the index of the segment, and the start and end points of the segment.
     *
     * @throws Will throw an error if the percentage is outside the range [0, 1].
     */
    getSegmentAt(percentage: number): {
        distanceToStart: number;
        index: number;
        startPoint: THREE.Vector3;
        endPoint: THREE.Vector3;
    };
    /**
     * Calculates the percentage of the curve that corresponds to the given point.
     *
     * @param point - The point for which to calculate the percentage.
     * @param tolerance - The tolerance for determining if a point is on the curve. Default is 0.01.
     * @returns The percentage of the curve that corresponds to the given point, or null if the point is not contained in this curve.
     *
     * @remarks
     * The method works by iterating over each segment of the curve and checking if the given point is within the tolerance of the segment.
     * If a point is found, it calculates the percentage of the curve that corresponds to the point.
     * If no point is found, it returns null.
     */
    getPercentageAt(point: THREE.Vector3, tolerance?: number): number | null;
    /**
     * Retrieves a segment of the curve based on the given index.
     *
     * @param index - The index of the segment.
     * @returns An object containing the start and end points of the segment.
     *
     * @remarks
     * The method calculates the start and end points of the segment based on the given index.
     * It uses the index array and position attribute of the curve's geometry to determine the start and end points.
     *
     * @throws Will throw an error if the index is out of range.
     */
    getSegment(index: number): {
        startPoint: THREE.Vector3;
        endPoint: THREE.Vector3;
    };
}

declare class Connection {
    private readonly _handlers;
    private readonly _handleInput;
    private _port?;
    constructor(handleInput: ThreadHandler);
    fetchMeshCompute(modelId: string, list: any[]): void;
    fetch(input: any, content?: any[]): Promise<any>;
    init(port: MessagePort): void;
    protected initConnection(connection: MessagePort): void;
    protected fetchConnection(_input: any): Promise<MessagePort>;
    private executeConnection;
    private manageOutput;
    private onInput;
    private manageConnection;
    private manageInput;
}

/**
 * Enum representing the current level of detail (LOD) for a mesh.
 */
export declare const enum CurrentLod {
    /** Represents the full geometry of the model */
    GEOMETRY = 0,
    /** Represents the wireframe representation of the model */
    WIRES = 1,
    /** Represents the invisible representation of the model */
    INVISIBLE = 2
}

/**
 * Represents an alignment 3D curve mesh with additional civil engineering properties. Extends THREE.LineSegments to provide geometry and material for the curve.
 *
 * @template TGeometry - The type of geometry for the curve mesh. Default is THREE.BufferGeometry.
 * @template TMaterial - The type of material(s) for the curve mesh. Default is THREE.Material or THREE.Material[].
 */
export declare class CurveMesh<TGeometry extends THREE.BufferGeometry = THREE.BufferGeometry, TMaterial extends THREE.Material | THREE.Material[] = THREE.Material | THREE.Material[]> extends THREE.LineSegments<TGeometry, TMaterial> {
    /**
     * The civil curve associated with this curve mesh.
     */
    curve: CivilCurve;
    /**
     * Constructs a new instance of CurveMesh.
     *
     * @param index - The index of the curve mesh.
     * @param data - The data associated with the curve mesh.
     * @param alignment - The alignment of the curve mesh.
     * @param geometry - The geometry for the curve mesh. Optional.
     * @param material - The material(s) for the curve mesh. Optional.
     */
    constructor(index: number, data: {
        [name: string]: any;
    }, alignment: AlignmentObject, geometry?: TGeometry, material?: TMaterial);
}

/**
 * Union type representing all possible data buffer types.
 */
export declare type DataBuffer = Float32Array | Uint8ClampedArray | Int32Array | Uint8Array | Uint32Array | Float64Array | Int8Array | Uint16Array | Int16Array;

export declare class DataMap<K, V> extends Map<K, V> {
    readonly onItemSet: Event_2<{
        key: K;
        value: V;
    }>;
    readonly onItemUpdated: Event_2<{
        key: K;
        value: V;
    }>;
    readonly onItemDeleted: Event_2<K>;
    readonly onBeforeDelete: Event_2<{
        key: K;
        value: V;
    }>;
    readonly onCleared: Event_2<unknown>;
    constructor(iterable?: Iterable<readonly [K, V]> | null | undefined);
    clear(): void;
    set(key: K, value: V): this;
    guard: (key: K, value: V) => boolean;
    delete(key: K): boolean;
    dispose(): void;
}

export declare class DataSet<T> extends Set<T> {
    readonly onItemAdded: Event_2<T>;
    readonly onBeforeDelete: Event_2<T>;
    readonly onItemDeleted: Event_2<unknown>;
    readonly onCleared: Event_2<unknown>;
    constructor(iterable?: Iterable<T> | null);
    clear(): void;
    add(...value: T[]): this;
    guard: (value: T) => boolean;
    delete(value: T): boolean;
    dispose(): void;
}

export declare class DoubleVector {
    bb: flatbuffers.ByteBuffer | null;
    bb_pos: number;
    __init(i: number, bb: flatbuffers.ByteBuffer): DoubleVector;
    x(): number;
    mutate_x(value: number): boolean;
    y(): number;
    mutate_y(value: number): boolean;
    z(): number;
    mutate_z(value: number): boolean;
    static sizeOf(): number;
    static createDoubleVector(builder: flatbuffers.Builder, x: number, y: number, z: number): flatbuffers.Offset;
}

declare class Event_2<T> {
    enabled: boolean;
    add(handler: T extends void ? {
        (): void;
    } : {
        (data: T): void;
    }): void;
    remove(handler: T extends void ? {
        (): void;
    } : {
        (data: T): void;
    }): void;
    trigger: (data?: T) => void;
    reset(): void;
    private handlers;
}
export { Event_2 as Event }

export declare class FloatVector {
    bb: flatbuffers.ByteBuffer | null;
    bb_pos: number;
    __init(i: number, bb: flatbuffers.ByteBuffer): FloatVector;
    x(): number;
    mutate_x(value: number): boolean;
    y(): number;
    mutate_y(value: number): boolean;
    z(): number;
    mutate_z(value: number): boolean;
    static sizeOf(): number;
    static createFloatVector(builder: flatbuffers.Builder, x: number, y: number, z: number): flatbuffers.Offset;
}

export declare class Fragment {
    ids: Set<number>;
    itemToInstances: Map<number, Set<number>>;
    instanceToItem: Map<number, number>;
    hiddenItems: Set<number>;
    id: string;
    mesh: FragmentMesh;
    capacity: number;
    capacityOffset: number;
    group?: FragmentsGroup;
    get uniqueVertices(): THREE.Vector3[];
    private _originalColors;
    private _settingVisibility;
    constructor(geometry: THREE.BufferGeometry, material: THREE.Material | THREE.Material[], count: number);
    dispose(disposeResources?: boolean): void;
    get(itemID: number): Item;
    getItemID(instanceID: number): number | null;
    getInstancesIDs(itemID: number): Set<number> | null;
    update(): void;
    add(items: Item[]): void;
    remove(itemsIDs: Iterable<number>): void;
    clear(): void;
    setVisibility(visible: boolean, itemIDs?: Iterable<number>): void;
    setColor(color: THREE.Color, itemIDs?: Iterable<number>, override?: boolean): void;
    resetColor(itemIDs?: Iterable<number>): void;
    applyTransform(itemIDs: Iterable<number>, transform: THREE.Matrix4): void;
    exportData(): {
        ids: number[];
        id: string;
        position: Float32Array;
        normal: Float32Array;
        index: number[];
        groups: number[];
        materials: number[];
        matrices: number[];
        colors: number[];
    };
    clone(itemIDs?: Iterable<number>): Fragment;
    private putLast;
}

export declare interface FragmentIdMap {
    [fragmentID: string]: Set<number>;
}

export declare class FragmentMesh extends THREE.InstancedMesh {
    fragment: Fragment;
    material: THREE.Material[];
    geometry: IndexedGeometry;
    constructor(geometry: THREE.BufferGeometry, material: THREE.Material | THREE.Material[], count: number, fragment: Fragment);
    exportData(): {
        position: Float32Array;
        normal: Float32Array;
        index: number[];
        groups: number[];
        materials: number[];
        matrices: number[];
        colors: number[];
    };
    clone(_recursive?: boolean): any;
}

/**
 * An interface that defines a fragment binary importer/exporter that uses flatbuffers. A parser of a specific version can only open files that were generated with that version. When opening a file, the library automatically traverses all available versions to find the right one. You can update your fragments to the latest version by generating them again from the original IFC file.
 */
declare interface FragmentParser {
    /**
     * The version of the parser. If set to "auto", it will automatically use the latest version, and, if it doesn't work, traverse the other versions from newer to older.
     */
    version: number | "auto";
    /**
     * Constructs a FragmentsGroup object from the given flatbuffers data.
     *
     * @param bytes - The flatbuffers data as Uint8Array.
     * @returns A FragmentsGroup object constructed from the flatbuffers data.
     */
    import(bytes: Uint8Array): FragmentsGroup;
    /**
     * Exports the FragmentsGroup to a flatbuffer binary file.
     *
     * @param group - The FragmentsGroup to be exported.
     * @returns The flatbuffer binary file as a Uint8Array.
     */
    export(group: FragmentsGroup): Uint8Array;
}

declare class FragmentsConnection extends Connection {
    private readonly _data;
    constructor(handleInput: ThreadHandler, threadPath: string);
    delete(model: string): void;
    invoke(model: string, method: string, args?: any[]): Promise<any>;
    protected fetchConnection(input: any): Promise<MessagePort>;
    private setupNewThread;
    private setupThread;
    private newThread;
}

export declare class FragmentsGroup extends THREE.Group {
    static fetch: (url: string) => Promise<File | Response>;
    static constructFileName: ((id: number) => string) | null;
    static url: string;
    static useCache: boolean;
    static propertiesDB: StreamerFileDb | null;
    items: Fragment[];
    boundingBox: THREE.Box3;
    coordinationMatrix: THREE.Matrix4;
    keyFragments: Map<number, string>;
    globalToExpressIDs: Map<string, number>;
    data: Map<number, [number[], number[]]>;
    geometryIDs: {
        opaque: Map<number, number>;
        transparent: Map<number, number>;
    };
    ifcMetadata: IfcMetadata;
    civilData?: {
        coordinationMatrix: THREE.Matrix4;
        alignments: Map<number, AlignmentObject>;
    };
    streamSettings: {
        baseUrl?: string;
        baseFileName: string;
        ids: Map<number, number>;
        types: Map<number, number[]>;
    };
    isStreamed: boolean;
    get hasProperties(): boolean;
    protected _properties?: IfcProperties;
    getFragmentMap(expressIDs?: Iterable<number>): FragmentIdMap;
    getItemVertices(itemID: number): THREE.Vector3[];
    static setPropertiesDB(enabled: boolean): void;
    dispose(disposeResources?: boolean): void;
    setLocalProperties(properties: IfcProperties): void;
    getLocalProperties(): IfcProperties | undefined;
    getAllPropertiesIDs(): number[];
    getAllPropertiesTypes(): number[];
    getProperties(id: number): Promise<{
        [attribute: string]: any;
    } | null>;
    setProperties(id: number, value: {
        [attribute: string]: any;
    } | null): Promise<void>;
    getAllPropertiesOfType(type: number): Promise<IfcProperties | null>;
    clone(_recursive?: boolean): any;
    cloneGroup(items?: FragmentIdMap): this;
    private getPropsURL;
    private getPropertiesData;
    private constructFileName;
    private disposeAlignment;
}

/**
 * The main class for managing a 3D model loaded from a fragments file. Handles geometry, materials, visibility, highlighting, sections, and more. This class orchestrates multiple specialized managers to handle different aspects of the model like mesh management, item data, raycasting, etc. It maintains the overall state and provides the main interface for interacting with the model. The model data is loaded and processed asynchronously across multiple threads.
 */
export declare class FragmentsModel {
    /**
     * A map of attribute changes that have occurred in the model.
     * The key is the local ID of the item, and the value is the change.
     */
    readonly attrsChanges: Map<number, AttrsChange>;
    /**
     * A map of relation changes that have occurred in the model.
     * The key is the local ID of the item, and the value is the change.
     */
    readonly relsChanges: Map<number, RelsModifyChange>;
    /**
     * The connection to the threads that handle the model data.
     */
    readonly threads: FragmentsConnection;
    /**
     * A map of tiles that have been loaded for the model.
     * The key is the tile ID, and the value is the tile.
     */
    readonly tiles: DataMap<string | number, BIMMesh>;
    /**
     * The object that represents the model in the Three.js scene.
     */
    object: THREE.Object3D<THREE.Object3DEventMap>;
    /**
     * The graphics quality of the model. It ranges from 0 (lowest) to 1 (highest).
     */
    graphicsQuality: number;
    private readonly _boxManager;
    private readonly _itemsManager;
    private readonly _coordinatesManager;
    private readonly _setupManager;
    private readonly _viewManager;
    private readonly _raycastManager;
    private readonly _visibilityManager;
    private readonly _highlightManager;
    private readonly _sectionManager;
    private readonly _dataManager;
    private readonly _sequenceManager;
    private readonly _bbox;
    private readonly _alignmentsManager;
    private readonly _meshManager;
    private _isProcessing;
    private _isLoaded;
    private _frozen;
    private _isSetup;
    /**
     * The ID of the model.
     */
    get modelId(): string;
    /**
     * The bounding box of the whole model.
     */
    get box(): THREE.Box3;
    /**
     * Whether the model is busy loading data.
     */
    get isBusy(): boolean;
    /**
     * Whether the model should stop updating..
     */
    get frozen(): boolean;
    /**
     * Whether the model should stop updating..
     */
    set frozen(value: boolean);
    /**
     * The event that is triggered when the clipping planes are needed in the thread.
     * Set this method to pass your Three.js clipping planes to the model.
     */
    get getClippingPlanesEvent(): () => THREE.Plane[];
    /**
     * The event that is triggered when the clipping planes are needed in the thread.
     * Set this method to pass your Three.js clipping planes to the model.
     */
    set getClippingPlanesEvent(value: () => THREE.Plane[]);
    /**
     * The constructor of the fragments model. Don't use this directly. Use the {@link FragmentsModels.load} instead.
     */
    constructor(modelId: string, meshManager: MeshManager, threads: FragmentsConnection);
    /**
     * Dispose the model. Use this when you're done with the model.
     * If you use the {@link FragmentsModels.dispose} method, this will be called automatically for all models.
     */
    dispose(): Promise<void>;
    /**
     * Get the spatial structure of the model.
     */
    getSpatialStructure(): Promise<SpatialTreeItem>;
    /**
     * Get the local IDs corresponding to the specified GUIDs.
     * @param guids - Array of GUIDs to look up.
     */
    getLocalIdsByGuids(guids: string[]): Promise<(number | null)[]>;
    /**
     * Get all the categories of the model.
     */
    getCategories(): Promise<string[]>;
    /**
     * Get all the items of the model that have geometry.
     */
    getItemsWithGeometry(): Promise<Item_2[]>;
    /**
     * Get the metadata of the model.
     */
    getMetadata<T extends Record<string, any> = Record<string, any>>(): Promise<T>;
    /**
     * Get the GUIDs corresponding to the specified local IDs.
     * @param localIds - Array of local IDs to look up.
     */
    getGuidsByLocalIds(localIds: number[]): Promise<(string | null)[]>;
    /**
     * Get the buffer of the model.
     * @param raw - Whether to get the raw buffer. If false, it will be compressed.
     */
    getBuffer(raw?: boolean): Promise<ArrayBuffer>;
    /**
     * Get all the items of the model that belong to the specified category.
     * @param category - The category to look up.
     */
    getItemsOfCategory(category: string): Promise<Item_2[]>;
    /**
     * Get the maximum local ID of the model.
     */
    getMaxLocalId(): Promise<number>;
    /**
     * Get an item by its ID.
     * @param id - The ID of the item to look up.
     */
    getItem(id: Identifier): Item_2;
    /**
     * Get the spatial structure children of the specified items.
     * @param ids - The IDs of the items to look up.
     */
    getItemsChildren(ids: Identifier[]): Promise<number[]>;
    /**
     * Get all the data of the specified items.
     * @param ids - The IDs of the items to look up.
     * @param config - The configuration of the items data.
     */
    getItemsData(ids: Identifier[], config?: Partial<ItemsDataConfig>): Promise<ItemData[]>;
    /**
     * Get the absolute positions of the specified items.
     * @param localIds - The local IDs of the items to look up.
     */
    getPositions(localIds?: number[]): Promise<THREE.Vector3[]>;
    /**
     * Gets coordinates of the model.
     */
    getCoordinates(): Promise<number[]>;
    /**
     * Get the merged bounding box of the specified items.
     * @param localIds - The local IDs of the items to look up.
     */
    getMergedBox(localIds: number[]): Promise<THREE.Box3>;
    /**
     * Get the individual bounding boxes of the specified items.
     * @param localIds - The local IDs of the items to look up.
     */
    getBoxes(localIds?: number[]): Promise<THREE.Box3[]>;
    /**
     * Get the civil alignments of the model (if any).
     */
    getAlignments(): Promise<THREE.Group<THREE.Object3DEventMap>>;
    /**
     * Get the civil alignment styles of the model (if any).
     */
    getAlignmentStyles(): Promise<{
        interior: THREE.PointsMaterial;
        exterior: THREE.PointsMaterial;
        0: LineMaterial;
        1: LineMaterial;
        2: LineMaterial;
        3: LineMaterial;
        4: LineMaterial;
    }>;
    /**
     * Sets a camera for the model. The model will use it to load tiles dinamically depending on the users view
     * (e.g. hiding items that are not in the view, setting the LOD to far away items, etc).
     * @param camera - The camera to use.
     */
    useCamera(camera: THREE.PerspectiveCamera | THREE.OrthographicCamera): void;
    /**
     * Performs a rectangle raycast on the model.
     * @param data - The data of the rectangle raycast.
     */
    rectangleRaycast(data: RectangleRaycastData): Promise<RectangleRaycastResult | null>;
    /**
     * Performs a raycast on the model.
     * @param data - The data of the raycast.
     */
    raycast(data: RaycastData): Promise<RaycastResult | null>;
    /**
     * Performs a raycast on the model with snapping.
     * @param data - The data of the raycast.
     */
    raycastWithSnapping(data: SnappingRaycastData): Promise<RaycastResult[] | null>;
    /**
     * Sets the visibility of the specified items.
     * @param localIds - The local IDs of the items to set the visibility of.
     * @param visible - Whether the items should be visible.
     */
    setVisible(localIds: number[] | undefined, visible: boolean): Promise<void>;
    /**
     * Toggles the visibility of the specified items.
     * @param localIds - The local IDs of the items to toggle the visibility of.
     */
    toggleVisible(localIds?: number[]): Promise<void>;
    /**
     * Gets the items by visibility.
     * @param visible - Whether the items should be visible.
     */
    getItemsByVisibility(visible: boolean): Promise<number[]>;
    /**
     * Gets the items by visibility.
     * @param localIds - The local IDs of the items to get the visibility of.
     */
    getVisible(localIds: number[]): Promise<boolean[]>;
    /**
     * Resets the visibility of all items.
     */
    resetVisible(): Promise<void>;
    /**
     * Highlights the specified items.
     * @param localIds - The local IDs of the items to highlight. If undefined, all items will be highlighted.
     * @param highlightMaterial - The material to use for the highlight.
     */
    highlight(localIds: number[] | undefined, highlightMaterial: MaterialDefinition): Promise<void>;
    /**
     * Gets the highlight of the specified items.
     * @param localIds - The local IDs of the items to get the highlight of. If undefined, it will return the highlight of all items.
     */
    getHighlight(localIds?: number[]): Promise<MaterialDefinition[]>;
    /**
     * Resets the highlight of the specified items.
     * @param localIds - The local IDs of the items to reset the highlight of. If undefined, it will reset the highlight of all items.
     */
    resetHighlight(localIds?: number[]): Promise<void>;
    /**
     * Gets the item IDs of the items that are highlighted.
     */
    getHighlightItemIds(): Promise<number[]>;
    /**
     * Gets the section (edges and fills) between the model and a given clipping plane.
     * @param plane - The plane to get the section of.
     */
    getSection(plane: THREE.Plane): Promise<any>;
    /**
     * Processes a sequence of actions in the worker and computes the result based on the provided input.
     *
     * @param result - The type of item information to compute, used to select the appropriate result function.
     * @param fromItems - An array of selection types, each corresponding to an items selector function.
     * @param input - The initial input data to be processed by the sequence of actions.
     * @returns The computed result after processing the sequence of actions, or `null` if the result function is not found.
     * @experimental
     */
    getSequenced<T extends ItemInformationType, U extends ItemSelectionType>(result: T, fromItems: U[], inputs?: {
        selector?: Partial<Record<U, SelectionInputType<U>>>;
        result?: ResultInputType<T>;
    }): Promise<InformationResultType<T>>;
    handleRequest(request: any): Promise<void>;
    /**
     * Internal method to finish processing. Don't use this directly.
     */
    _finishProcessing(): void;
    /**
     * Internal method to refresh the view of the model. You shouldn't call this directly. Instead, use {@link FragmentsModels.update}.
     */
    _refreshView(): Promise<void>;
    /**
     * Internal method to set up the model. Don't use this directly.
     */
    _setup(data: ArrayBuffer, raw?: boolean, config?: VirtualModelConfig): Promise<void>;
}

/**
 * The main class for managing multiple 3D models loaded from fragments files. Handles loading, disposing, updating, raycasting, highlighting and coordinating multiple FragmentsModel instances. This class acts as the main entry point for working with fragments models.
 *
 */
export declare class FragmentsModels {
    /**
     * Event triggered when a model is loaded.
     * @event
     * @type {Event<FragmentsModel>}
     */
    readonly onModelLoaded: Event_2<FragmentsModel>;
    /**
     * The manager that handles all loaded fragments models.
     * Provides functionality to:
     * - Store and retrieve models by ID
     * - Track model loading/unloading
     * - Coordinate updates across models
     * - Handle model disposal
     */
    models: MeshManager;
    /** Settings that control the behavior of the FragmentsModels system */
    settings: {
        /** Whether to automatically coordinate model positions relative to the first loaded model */
        autoCoordinate: boolean;
        /** Maximum rate (in milliseconds) at which visual updates are performed */
        maxUpdateRate: number;
        /** Graphics quality level - 0 is low quality, 1 is high quality */
        graphicsQuality: number;
    };
    /** Coordinates of the first loaded model, used for coordinate system alignment */
    baseCoordinates: number[] | null;
    private readonly _connection;
    private _isDisposed;
    private _autoRedrawInterval;
    private _lastUpdate;
    /**
     * Creates a new FragmentsModels instance.
     * @param workerURL - The URL of the worker script that will handle the fragments processing.
     * This should point to a copy of the fragments worker file from @thatopen/fragments.
     */
    constructor(workerURL: string);
    /**
     * Loads a fragments model from an ArrayBuffer.
     * @param buffer - The ArrayBuffer containing the fragments data to load.
     * @param options - Configuration options for loading the model.
     * @param options.modelId - Unique identifier for the model.
     * @param options.camera - Optional camera to use for model culling and LOD.
     * @param options.raw - If true, loads raw (uncompressed) data. Default is false.
     * @param options.userData - Optional custom data to attach to the model.
     * @param options.virtualModelConfig - Optional configuration for virtual model setup.
     * @returns Promise resolving to the loaded FragmentsModel instance.
     */
    load(buffer: ArrayBuffer, options: {
        modelId: string;
        camera?: THREE.PerspectiveCamera | THREE.OrthographicCamera;
        raw?: boolean;
        userData?: Record<string, any>;
        virtualModelConfig?: VirtualModelConfig;
    }): Promise<FragmentsModel>;
    /**
     * Disposes of all models managed by this FragmentsModels instance.
     * After calling this method, the FragmentsModels instance should not be used anymore.
     */
    dispose(): Promise<void>;
    /**
     * Disposes of a specific model by its ID.
     * @param modelId - The unique identifier of the model to dispose.
     */
    disposeModel(modelId: string): Promise<void>;
    /**
     * Updates all models managed by this FragmentsModels instance.
     * @param force - If true, it will force all the models to finish all the pending requests.
     */
    update(force?: boolean): Promise<void>;
    private manageRequest;
    private newUpdateEvent;
    private newRequestEvent;
}

export declare class FragmentUtils {
    static combine(maps: FragmentIdMap[]): FragmentIdMap;
    static intersect(maps: FragmentIdMap[]): FragmentIdMap;
    static copy(map: FragmentIdMap): FragmentIdMap;
    static export(map: FragmentIdMap): {
        [fragID: string]: number[];
    };
    static import(serialized: {
        [fragID: string]: number[];
    }): FragmentIdMap;
}

export declare class Geometries {
    bb: flatbuffers.ByteBuffer | null;
    bb_pos: number;
    __init(i: number, bb: flatbuffers.ByteBuffer): Geometries;
    static getRootAsGeometries(bb: flatbuffers.ByteBuffer, obj?: Geometries): Geometries;
    static getSizePrefixedRootAsGeometries(bb: flatbuffers.ByteBuffer, obj?: Geometries): Geometries;
    samples(index: number, obj?: GeometrySample): GeometrySample | null;
    samplesLength(): number;
    transforms(index: number, obj?: Transform): Transform | null;
    transformsLength(): number;
    lines(index: number, obj?: GeometryLines): GeometryLines | null;
    linesLength(): number;
    static startGeometries(builder: flatbuffers.Builder): void;
    static addSamples(builder: flatbuffers.Builder, samplesOffset: flatbuffers.Offset): void;
    static startSamplesVector(builder: flatbuffers.Builder, numElems: number): void;
    static addTransforms(builder: flatbuffers.Builder, transformsOffset: flatbuffers.Offset): void;
    static startTransformsVector(builder: flatbuffers.Builder, numElems: number): void;
    static addLines(builder: flatbuffers.Builder, linesOffset: flatbuffers.Offset): void;
    static createLinesVector(builder: flatbuffers.Builder, data: flatbuffers.Offset[]): flatbuffers.Offset;
    static startLinesVector(builder: flatbuffers.Builder, numElems: number): void;
    static endGeometries(builder: flatbuffers.Builder): flatbuffers.Offset;
    static createGeometries(builder: flatbuffers.Builder, samplesOffset: flatbuffers.Offset, transformsOffset: flatbuffers.Offset, linesOffset: flatbuffers.Offset): flatbuffers.Offset;
}

export declare enum GeometryClass {
    NONE = 0,
    LINES = 1,
    ELLIPSE_ARC = 2,
    CLOTHOID = 3,
    PARABOLA = 4
}

export declare class GeometryLines {
    bb: flatbuffers.ByteBuffer | null;
    bb_pos: number;
    __init(i: number, bb: flatbuffers.ByteBuffer): GeometryLines;
    static getRootAsGeometryLines(bb: flatbuffers.ByteBuffer, obj?: GeometryLines): GeometryLines;
    static getSizePrefixedRootAsGeometryLines(bb: flatbuffers.ByteBuffer, obj?: GeometryLines): GeometryLines;
    points(index: number, obj?: FloatVector): FloatVector | null;
    pointsLength(): number;
    static startGeometryLines(builder: flatbuffers.Builder): void;
    static addPoints(builder: flatbuffers.Builder, pointsOffset: flatbuffers.Offset): void;
    static startPointsVector(builder: flatbuffers.Builder, numElems: number): void;
    static endGeometryLines(builder: flatbuffers.Builder): flatbuffers.Offset;
    static createGeometryLines(builder: flatbuffers.Builder, pointsOffset: flatbuffers.Offset): flatbuffers.Offset;
}

export declare class GeometrySample {
    bb: flatbuffers.ByteBuffer | null;
    bb_pos: number;
    __init(i: number, bb: flatbuffers.ByteBuffer): GeometrySample;
    geometryClass(): GeometryClass;
    mutate_geometry_class(value: GeometryClass): boolean;
    id(): number;
    mutate_id(value: number): boolean;
    transform(): number;
    mutate_transform(value: number): boolean;
    static sizeOf(): number;
    static createGeometrySample(builder: flatbuffers.Builder, geometry_class: GeometryClass, id: number, transform: number): flatbuffers.Offset;
}

/**
 * Recursively converts a Flatbuffers object into a plain JavaScript object. This function traverses the prototype chain of the Flatbuffers object and extracts all properties and their values, handling both primitive values and nested objects/arrays.
 *
 * @param obj - The Flatbuffers object to convert
 * @param result - The target plain JavaScript object where the converted properties will be stored
 *
 */
export declare function getObject(obj: any, result: any): void;

/**
 * Type representing a unique identifier for a model item. This can be either a string or a number.
 */
export declare type Identifier = string | number;

/**
 * A map that associates each unique integer identifier (IFC Entity ID) with its corresponding category name. This map is used to map IFC entities to their respective categories for easier identification and processing.
 */
export declare const ifcCategoryMap: {
    [key: number]: string;
};

/**
 * An objet to convert IFC files into fragments.
 */
export declare class IfcImporter {
    private _builder;
    /** Configuration for the web-ifc WASM module
     * @property {string} path - The path to the web-ifc WASM files
     * @property {boolean} absolute - Whether the path is absolute or relative
     */
    wasm: {
        path: string;
        absolute: boolean;
    };
    /** A set of attribute names to exclude from serialization.
     * By default excludes "Representation" and "ObjectPlacement" attributes.
     */
    attrsToExclude: Set<string>;
    private get builder();
    /**
     * Processes IFC data and converts it into a fragments format.
     * @param data Configuration object for processing.
     * @param data.bytes Raw IFC file data as Uint8Array.
     * @param data.raw Whether to return raw uncompressed data. If false, the output fragments will be smaller.
     * @param data.readFromCallback Whether to read data from a callback function. Useful for node.js.
     * @param data.readCallback Callback function to read IFC data. Useful for node.js.
     */
    process(data: {
        readFromCallback?: boolean;
        bytes?: Uint8Array;
        readCallback?: any;
        raw?: boolean;
    }): Promise<Uint8Array>;
    private clean;
}

export declare interface IfcMetadata {
    name: string;
    description: string;
    schema: IfcSchema;
    maxExpressID: number;
}

export declare interface IfcProperties {
    [expressID: number]: {
        [attribute: string]: any;
    };
}

export declare type IfcSchema = "IFC2X3" | "IFC4" | "IFC4X3";

export declare interface IndexedGeometry extends THREE.BufferGeometry {
    index: THREE.BufferAttribute;
}

/**
 * Type representing the result of an information query for a specific item type.
 * @template T - The type of item information to query.
 */
export declare type InformationResultType<T extends ItemInformationType> = MappedInformationResult[T];

export declare interface Item {
    id: number;
    transforms: THREE.Matrix4[];
    colors?: THREE.Color[];
}

/**
 * Represents a single item in a Fragments model.
 * This class provides methods to access and retrieve information about the item,
 * including its attributes, relations, geometry, and data.
 */
declare class Item_2 {
    /**
     * The FragmentsModel instance that this item belongs to.
     */
    readonly model: FragmentsModel;
    /**
     * Creates a new Item instance.
     * @param model - The FragmentsModel instance that this item belongs to.
     * @param id - The identifier for the item, which can be either a number or a string.
     */
    constructor(model: FragmentsModel, id: Identifier);
    private _localId;
    /**
     * Gets the local ID of the item.
     */
    getLocalId(): Promise<number | null>;
    private _attributes;
    /**
     * Gets all the attributes of the item.
     */
    getAttributes(): Promise<ItemAttributes | null>;
    private _relations;
    /**
     * Gets all the relations of the item to other items.
     */
    getRelations(): Promise<ItemRelations | null>;
    private _guid;
    /**
     * Gets the GUID of the item.
     */
    getGuid(): Promise<string | null>;
    private _category;
    /**
     * Gets the category of the item.
     */
    getCategory(): Promise<string | null>;
    private _geometry;
    getGeometry(): Promise<ItemGeometry | null>;
    /**
     * Gets all the data of the item.
     */
    getData(collector?: number[]): Promise<{
        [x: string]: any;
    }>;
}

/**
 * Interface representing the attributes of an item in a Fragments model.
 */
export declare interface ItemAttribute {
    /** The value of the attribute, which can be any type */
    value: any;
    /** Optional type identifier for the attribute value */
    type?: string;
}

/**
 * Represents a collection of attributes for an item in a Fragments model.
 * This class extends the Map class to provide additional functionality for managing attributes.
 */
declare class ItemAttributes extends Map<string, AttributeData> {
    /**
     * A map of local IDs to their corresponding attribute changes.
     * This is used to track changes to the attributes over time.
     */
    tracker: Map<number, AttrsChange> | null;
    /**
     * The local ID of the item.
     */
    localId: number;
    /**
     * Gets the attributes as a plain javascript object.
     */
    get object(): Record<string, any>;
    /**
     * Creates a new ItemAttributes instance.
     * @param localId - The local ID of the item.
     * @param iterable - An optional iterable of key-value pairs to initialize the map with.
     */
    constructor(localId: number, iterable?: Iterable<readonly [string, AttributeData]> | null | undefined);
    /**
     * A function that acts as a guard for adding items to the set.
     * It determines whether a given value should be allowed to be added to the set.
     *
     * @param key - The key of the entry to be checked against the guard.
     * @param value - The value of the entry to be checked against the guard.
     * @returns A boolean indicating whether the value should be allowed to be added to the set.
     *          By default, this function always returns true, allowing all values to be added.
     *          You can override this behavior by providing a custom implementation.
     */
    guard: (key: string, value: AttributeData) => boolean;
    /**
     * Sets an attribute in the map.
     * @param key - The key of the attribute to set.
     * @param attr - The attribute data to set.
     * @returns The updated map.
     */
    set(key: string, attr: AttributeData): this;
    /**
     * Sets the value of an attribute in the map.
     * @param key - The key of the attribute to set.
     * @param value - The value of the attribute to set.
     * @returns The updated map.
     */
    setValue(key: string, value: any): this;
    /**
     * Sets the type of an attribute in the map.
     * @param key - The key of the attribute to set.
     * @param type - The type of the attribute to set.
     * @returns The updated map.
     */
    setType(key: string, type: number): this;
    /**
     * Deletes an attribute from the map.
     * @param key - The key of the attribute to delete.
     * @returns The updated map.
     */
    delete(key: string): boolean;
    /**
     * Gets the value of an attribute from the map.
     * @param key - The key of the attribute to get.
     */
    getValue(key: string): any;
    /**
     * Gets the type of an attribute from the map.
     * @param key - The key of the attribute to get.
     */
    getType(key: string): number | undefined;
}

/**
 * Enum representing the configuration class for an item in a Fragments model.
 */
export declare enum ItemConfigClass {
    /** Represents the visibility configuration for an item */
    VISIBLE = 0
}

/**
 * Interface representing the data of an item in a Fragments model.
 */
export declare interface ItemData {
    [name: string]: ItemAttribute | ItemData[];
}

/**
 * Represents the geometry of an item in a Fragments model.
 */
declare class ItemGeometry {
    /**
     * The model that the geometry belongs to.
     */
    readonly model: FragmentsModel;
    /**
     * The local ID of the item.
     */
    localId: number;
    /**
     * Creates a new ItemGeometry instance.
     * @param model - The model that the geometry belongs to.
     * @param localId - The local ID of the item.
     */
    constructor(model: FragmentsModel, localId: number);
    private getGeometry;
    private _indices;
    /**
     * Gets the indices of the item.
     */
    getIndices(): Promise<Uint8Array[] | Uint16Array[] | Uint32Array[] | null>;
    private _transform;
    /**
     * Gets the transform of the item.
     */
    getTransform(): Promise<THREE.Matrix4[] | null>;
    private _normals;
    /**
     * Gets the normals of the item.
     */
    getNormals(): Promise<Int16Array[] | null>;
    private _positions;
    /**
     * Gets the positions of the item.
     */
    getPositions(): Promise<Float32Array[] | Float64Array[] | null>;
    private _vertices;
    /**
     * Gets the vertices of the item.
     */
    getVertices(): Promise<THREE.Vector3[][] | null>;
    private _triangles;
    /**
     * Gets the triangles of the item.
     */
    getTriangles(): Promise<THREE.Triangle[][] | null>;
    private _position;
    /**
     * Gets the position of the item.
     */
    getPosition(): Promise<THREE.Vector3[] | null>;
    private _box;
    /**
     * Gets the box of the item.
     */
    getBox(): Promise<THREE.Box3[] | null>;
    /**
     * Sets the visibility of the item.
     * @param visible - Whether the item should be visible.
     */
    setVisibility(visible: boolean): Promise<void>;
    /**
     * Gets the visibility of the item.
     */
    getVisibility(): Promise<boolean>;
}

/**
 * Union type representing all possible item information types.
 */
export declare type ItemInformationType = "data" | "attributes" | "relations" | "guid" | "category" | "geometry" | "visibility" | "highlight" | "mergedBoxes" | "children";

/**
 * A class that extends Map to store and manage relations between items in a Fragments model.
 * Each relation is stored as a key-value pair where the key is a string identifier and
 * the value is a Set of item IDs that are related through that relation.
 */
declare class ItemRelations extends Map<string, Set<number>> {
    /**
     * A map that tracks the changes to the relations of the item.
     */
    tracker: Map<number, RelsChange> | null;
    /**
     * The local ID of the item.
     */
    localId: number;
    private get itemChanges();
    /**
     * Creates a new ItemRelations instance.
     * @param localId - The local ID of the item.
     * @param iterable - An optional iterable of key-value pairs to initialize the map with.
     */
    constructor(localId: number, iterable?: Iterable<readonly [string, Set<number>]> | null | undefined);
    /**
     * A function that acts as a guard for adding items to the set.
     * It determines whether a given value should be allowed to be added to the set.
     *
     * @param key - The key of the entry to be checked against the guard.
     * @param value - The value of the entry to be checked against the guard.
     * @returns A boolean indicating whether the value should be allowed to be added to the set.
     *          By default, this function always returns true, allowing all values to be added.
     *          You can override this behavior by providing a custom implementation.
     */
    guard: (key: string, value: Set<number>) => boolean;
    /**
     * Sets a new relation in the map.
     * @param key - The key of the relation.
     * @param value - The value of the relation.
     * @returns The ItemRelations instance.
     */
    set(key: string, value: Set<number>): this;
    /**
     * Adds a new item to a target relation.
     * @param key - The key of the relation.
     * @param item - The item to add to the relation.
     */
    add(key: string, item: number): boolean;
    /**
     * Removes an item from a target relation.
     * @param key - The key of the relation.
     * @param item - The item to remove from the relation.
     * @returns A boolean indicating whether the item was removed from the relation.
     */
    remove(key: string, item: number): boolean;
    /**
     * Deletes a relation from the map.
     * @param key - The key of the relation to delete.
     */
    delete(key: string): boolean;
    /**
     * An event handler that is called when items are requested.
     */
    onItemsRequested: ((ids: number[], includeRelations?: boolean) => Promise<Item_2[]>) | null;
    /**
     * Gets the items of a relation.
     * @param key - The key of the relation.
     */
    getItems(key: string): Promise<Item_2[] | null>;
}

/**
 * Interface representing the configuration for item data in a Fragments model.
 */
export declare interface ItemsDataConfig {
    /**
     * An array of attribute names to include in the item data.
     */
    attributes?: string[];
    /**
     * A boolean indicating whether to include default attributes in the item data.
     */
    attributesDefault: boolean;
    /**
     * A record of relation names to their configuration.
     */
    relations?: Record<string, {
        attributes: boolean;
        relations: boolean;
    }>;
    /**
     * The default configuration for relations.
     */
    relationsDefault: {
        attributes: boolean;
        relations: boolean;
    };
}

/**
 * Union type representing all possible item selection types.
 */
export declare type ItemSelectionType = "withCondition" | "ofCategory" | "withGeometry" | "children" | "withVisiblity" | "highlighted";

/**
 * The maximum value for a 2-byte unsigned integer.
 */
export declare const limitOf2Bytes = 65536;

declare class LODGeometry extends THREE.InstancedBufferGeometry {
    isLODGeometry: boolean;
    isFiltered(): boolean;
    constructor();
    computeBoundingBox(): void;
    applyMatrix4(matrix: THREE.Matrix4): this;
    computeBoundingSphere(): void;
    getItemFilter(): THREE.InstancedBufferAttribute;
    getItemLast(): THREE.InterleavedBufferAttribute;
    getItemFirst(): THREE.InterleavedBufferAttribute;
    private applyTransformToBuffers;
    private updateBounds;
}

declare class LODManager {
    private _materials;
    private readonly white;
    constructor(materials: MaterialManager);
    createMesh(geometry: THREE.BufferGeometry, request: any): LODMesh;
    updateVisibility(mesh: LODMesh, status: any): void;
    processMesh(mesh: BIMMesh, request: any): void;
    private deleteAttributeEvent;
}

declare class LodMaterial extends THREE.ShaderMaterial {
    readonly isLodMaterial = true;
    readonly isLineMaterial = true;
    get lodSize(): THREE.Vector2;
    set lodColor(color: THREE.Color);
    set lodSize(value: THREE.Vector2);
    get lodColor(): THREE.Color;
    constructor(parameters: LineMaterialParameters);
}

declare class LODMesh extends THREE.Mesh {
    geometry: LODGeometry;
    material: LodMaterial[];
    constructor(geometry: LODGeometry, material: LodMaterial[]);
}

/**
 * Interface representing the result of an information query for a specific item type.
 * @template T - The type of item information to query.
 */
export declare interface MappedInformationResult {
    /**
     * An array of attribute records for the item.
     * Each record contains a string key and a value of type any.
     */
    attributes: (Record<string, {
        value: any;
        type?: string;
    }> | null)[];
    /**
     * An array of category strings for the item.
     */
    category: string[];
    /**
     * An array of child item IDs for the item.
     */
    children: number[];
    /**
     * An array of data records for the item.
     */
    data: ItemData[];
    /**
     * An array of geometry data for the item.
     */
    geometry: MeshData[][];
    /**
     * An array of GUID strings for the item.
     */
    guid: (string | null)[];
    /**
     * An array of highlight materials for the item.
     */
    highlight: MaterialDefinition[];
    /**
     * An array of relation records for the item.
     */
    relations: (Record<string, number[]> | null)[];
    /**
     * An array of visibility flags for the item.
     */
    visibility: boolean[];
    /**
     * The merged bounding box for the item.
     */
    mergedBoxes: THREE.Box3;
}

/**
 * Interface representing the input for a result query in a Fragments model.
 * @template T - The type of item information to query.
 */
export declare interface MappedResultInput {
    /**
     * A partial configuration for item data.
     */
    data: Partial<ItemsDataConfig>;
}

/**
 * Interface representing the input for a selection query in a Fragments model.
 */
export declare interface MappedSelectionInput {
    /**
     * The category of the item to select.
     */
    ofCategory: string;
}

export declare class Material {
    bb: flatbuffers.ByteBuffer | null;
    bb_pos: number;
    __init(i: number, bb: flatbuffers.ByteBuffer): Material;
    r(): number;
    mutate_r(value: number): boolean;
    g(): number;
    mutate_g(value: number): boolean;
    b(): number;
    mutate_b(value: number): boolean;
    a(): number;
    mutate_a(value: number): boolean;
    renderedFaces(): RenderedFaces;
    mutate_rendered_faces(value: RenderedFaces): boolean;
    stroke(): Stroke;
    mutate_stroke(value: Stroke): boolean;
    static sizeOf(): number;
    static createMaterial(builder: flatbuffers.Builder, r: number, g: number, b: number, a: number, rendered_faces: RenderedFaces, stroke: Stroke): flatbuffers.Offset;
}

export declare interface MaterialData {
    data: MaterialDefinition;
    transparent?: boolean;
    instancing?: boolean;
}

/**
 * Interface representing the definition of a material.
 */
export declare type MaterialDefinition = {
    /** The color of the material */
    color: THREE.Color;
    /** The faces rendered by the material */
    renderedFaces: RenderedFaces;
    /** The opacity of the material */
    opacity: number;
    /** Whether the material is transparent */
    transparent: boolean;
    /** An optional custom ID for the material */
    customId?: string;
};

declare class MaterialManager {
    readonly list: DataMap<number, BIMMaterial>;
    private readonly _modelMaterialMapping;
    private readonly _definitions;
    private readonly _idGenerator;
    private readonly white;
    static resetColors(definitions: MaterialDefinition[]): void;
    dispose(modelId: string): void;
    get(data: MaterialDefinition, request: any): BIMMaterial;
    addDefinitions(modelID: string, materials: MaterialDefinition[]): void;
    createHighlights(mesh: BIMMesh, request: any): THREE.Material[];
    getFromRequest(request: any): BIMMaterial;
    private newLODMaterial;
    private getParameters;
    private new;
    private addMaterialToModel;
    private processHighlight;
    private getUniqueMaterial;
}

/**
 * Interface representing the data of a mesh.
 */
export declare type MeshData = {
    /** The transformation matrix of the mesh */
    transform: THREE.Matrix4;
    /** The indices of the mesh */
    indices?: Uint8Array | Uint16Array | Uint32Array;
    /** The positions of the mesh */
    positions?: Float32Array | Float64Array;
    /** The normals of the mesh */
    normals?: Int16Array;
};

export declare class Meshes {
    bb: flatbuffers.ByteBuffer | null;
    bb_pos: number;
    __init(i: number, bb: flatbuffers.ByteBuffer): Meshes;
    static getRootAsMeshes(bb: flatbuffers.ByteBuffer, obj?: Meshes): Meshes;
    static getSizePrefixedRootAsMeshes(bb: flatbuffers.ByteBuffer, obj?: Meshes): Meshes;
    coordinates(obj?: Transform): Transform | null;
    meshesItems(index: number): number | null;
    meshesItemsLength(): number;
    meshesItemsArray(): Uint32Array | null;
    samples(index: number, obj?: Sample): Sample | null;
    samplesLength(): number;
    representations(index: number, obj?: Representation): Representation | null;
    representationsLength(): number;
    materials(index: number, obj?: Material): Material | null;
    materialsLength(): number;
    circleExtrusions(index: number, obj?: CircleExtrusion): CircleExtrusion | null;
    circleExtrusionsLength(): number;
    shells(index: number, obj?: Shell): Shell | null;
    shellsLength(): number;
    localTransforms(index: number, obj?: Transform): Transform | null;
    localTransformsLength(): number;
    globalTransforms(index: number, obj?: Transform): Transform | null;
    globalTransformsLength(): number;
    static startMeshes(builder: flatbuffers.Builder): void;
    static addCoordinates(builder: flatbuffers.Builder, coordinatesOffset: flatbuffers.Offset): void;
    static addMeshesItems(builder: flatbuffers.Builder, meshesItemsOffset: flatbuffers.Offset): void;
    static createMeshesItemsVector(builder: flatbuffers.Builder, data: number[] | Uint32Array): flatbuffers.Offset;
    /**
     * @deprecated This Uint8Array overload will be removed in the future.
     */
    static createMeshesItemsVector(builder: flatbuffers.Builder, data: number[] | Uint8Array): flatbuffers.Offset;
    static startMeshesItemsVector(builder: flatbuffers.Builder, numElems: number): void;
    static addSamples(builder: flatbuffers.Builder, samplesOffset: flatbuffers.Offset): void;
    static startSamplesVector(builder: flatbuffers.Builder, numElems: number): void;
    static addRepresentations(builder: flatbuffers.Builder, representationsOffset: flatbuffers.Offset): void;
    static startRepresentationsVector(builder: flatbuffers.Builder, numElems: number): void;
    static addMaterials(builder: flatbuffers.Builder, materialsOffset: flatbuffers.Offset): void;
    static startMaterialsVector(builder: flatbuffers.Builder, numElems: number): void;
    static addCircleExtrusions(builder: flatbuffers.Builder, circleExtrusionsOffset: flatbuffers.Offset): void;
    static createCircleExtrusionsVector(builder: flatbuffers.Builder, data: flatbuffers.Offset[]): flatbuffers.Offset;
    static startCircleExtrusionsVector(builder: flatbuffers.Builder, numElems: number): void;
    static addShells(builder: flatbuffers.Builder, shellsOffset: flatbuffers.Offset): void;
    static createShellsVector(builder: flatbuffers.Builder, data: flatbuffers.Offset[]): flatbuffers.Offset;
    static startShellsVector(builder: flatbuffers.Builder, numElems: number): void;
    static addLocalTransforms(builder: flatbuffers.Builder, localTransformsOffset: flatbuffers.Offset): void;
    static startLocalTransformsVector(builder: flatbuffers.Builder, numElems: number): void;
    static addGlobalTransforms(builder: flatbuffers.Builder, globalTransformsOffset: flatbuffers.Offset): void;
    static startGlobalTransformsVector(builder: flatbuffers.Builder, numElems: number): void;
    static endMeshes(builder: flatbuffers.Builder): flatbuffers.Offset;
    static createMeshes(builder: flatbuffers.Builder, coordinatesOffset: flatbuffers.Offset, meshesItemsOffset: flatbuffers.Offset, samplesOffset: flatbuffers.Offset, representationsOffset: flatbuffers.Offset, materialsOffset: flatbuffers.Offset, circleExtrusionsOffset: flatbuffers.Offset, shellsOffset: flatbuffers.Offset, localTransformsOffset: flatbuffers.Offset, globalTransformsOffset: flatbuffers.Offset): flatbuffers.Offset;
}

/**
 * A class that manages the creation and updating of meshes in a Fragments model.
 */
declare class MeshManager {
    /**
     * A map of FragmentsModel instances by their model ID.
     */
    readonly list: DataMap<string, FragmentsModel>;
    readonly materials: MaterialManager;
    readonly lod: LODManager;
    readonly requests: RequestsManager;
    private readonly updateThreshold;
    private _updateFinished;
    private _onUpdate;
    constructor(onUpdate: () => void);
    forceUpdateFinish(rate?: number): Promise<void>;
    update(): void;
    private setTileData;
    private processTileRequest;
    private createMesh;
    private setupBoundings;
    private create;
    private updateStatus;
    private cleanAttributeMemory;
    private setPositions;
    private setIndex;
    private setNormals;
    private setItemIds;
    private deleteAttribute;
    private setMeshData;
}

export declare class Model {
    bb: flatbuffers.ByteBuffer | null;
    bb_pos: number;
    __init(i: number, bb: flatbuffers.ByteBuffer): Model;
    static getRootAsModel(bb: flatbuffers.ByteBuffer, obj?: Model): Model;
    static getSizePrefixedRootAsModel(bb: flatbuffers.ByteBuffer, obj?: Model): Model;
    static bufferHasIdentifier(bb: flatbuffers.ByteBuffer): boolean;
    metadata(): string | null;
    metadata(optionalEncoding: flatbuffers.Encoding): string | Uint8Array | null;
    guids(index: number): string;
    guids(index: number, optionalEncoding: flatbuffers.Encoding): string | Uint8Array;
    guidsLength(): number;
    guidsItems(index: number): number | null;
    guidsItemsLength(): number;
    guidsItemsArray(): Uint32Array | null;
    maxLocalId(): number;
    mutate_max_local_id(value: number): boolean;
    localIds(index: number): number | null;
    localIdsLength(): number;
    localIdsArray(): Uint32Array | null;
    categories(index: number): string;
    categories(index: number, optionalEncoding: flatbuffers.Encoding): string | Uint8Array;
    categoriesLength(): number;
    meshes(obj?: Meshes): Meshes | null;
    attributes(index: number, obj?: Attribute): Attribute | null;
    attributesLength(): number;
    relations(index: number, obj?: Relation): Relation | null;
    relationsLength(): number;
    relationsItems(index: number): number | null;
    relationsItemsLength(): number;
    relationsItemsArray(): Int32Array | null;
    guid(): string | null;
    guid(optionalEncoding: flatbuffers.Encoding): string | Uint8Array | null;
    spatialStructure(obj?: SpatialStructure): SpatialStructure | null;
    alignments(index: number, obj?: Alignment): Alignment | null;
    alignmentsLength(): number;
    geometries(obj?: Geometries): Geometries | null;
    static startModel(builder: flatbuffers.Builder): void;
    static addMetadata(builder: flatbuffers.Builder, metadataOffset: flatbuffers.Offset): void;
    static addGuids(builder: flatbuffers.Builder, guidsOffset: flatbuffers.Offset): void;
    static createGuidsVector(builder: flatbuffers.Builder, data: flatbuffers.Offset[]): flatbuffers.Offset;
    static startGuidsVector(builder: flatbuffers.Builder, numElems: number): void;
    static addGuidsItems(builder: flatbuffers.Builder, guidsItemsOffset: flatbuffers.Offset): void;
    static createGuidsItemsVector(builder: flatbuffers.Builder, data: number[] | Uint32Array): flatbuffers.Offset;
    /**
     * @deprecated This Uint8Array overload will be removed in the future.
     */
    static createGuidsItemsVector(builder: flatbuffers.Builder, data: number[] | Uint8Array): flatbuffers.Offset;
    static startGuidsItemsVector(builder: flatbuffers.Builder, numElems: number): void;
    static addMaxLocalId(builder: flatbuffers.Builder, maxLocalId: number): void;
    static addLocalIds(builder: flatbuffers.Builder, localIdsOffset: flatbuffers.Offset): void;
    static createLocalIdsVector(builder: flatbuffers.Builder, data: number[] | Uint32Array): flatbuffers.Offset;
    /**
     * @deprecated This Uint8Array overload will be removed in the future.
     */
    static createLocalIdsVector(builder: flatbuffers.Builder, data: number[] | Uint8Array): flatbuffers.Offset;
    static startLocalIdsVector(builder: flatbuffers.Builder, numElems: number): void;
    static addCategories(builder: flatbuffers.Builder, categoriesOffset: flatbuffers.Offset): void;
    static createCategoriesVector(builder: flatbuffers.Builder, data: flatbuffers.Offset[]): flatbuffers.Offset;
    static startCategoriesVector(builder: flatbuffers.Builder, numElems: number): void;
    static addMeshes(builder: flatbuffers.Builder, meshesOffset: flatbuffers.Offset): void;
    static addAttributes(builder: flatbuffers.Builder, attributesOffset: flatbuffers.Offset): void;
    static createAttributesVector(builder: flatbuffers.Builder, data: flatbuffers.Offset[]): flatbuffers.Offset;
    static startAttributesVector(builder: flatbuffers.Builder, numElems: number): void;
    static addRelations(builder: flatbuffers.Builder, relationsOffset: flatbuffers.Offset): void;
    static createRelationsVector(builder: flatbuffers.Builder, data: flatbuffers.Offset[]): flatbuffers.Offset;
    static startRelationsVector(builder: flatbuffers.Builder, numElems: number): void;
    static addRelationsItems(builder: flatbuffers.Builder, relationsItemsOffset: flatbuffers.Offset): void;
    static createRelationsItemsVector(builder: flatbuffers.Builder, data: number[] | Int32Array): flatbuffers.Offset;
    /**
     * @deprecated This Uint8Array overload will be removed in the future.
     */
    static createRelationsItemsVector(builder: flatbuffers.Builder, data: number[] | Uint8Array): flatbuffers.Offset;
    static startRelationsItemsVector(builder: flatbuffers.Builder, numElems: number): void;
    static addGuid(builder: flatbuffers.Builder, guidOffset: flatbuffers.Offset): void;
    static addSpatialStructure(builder: flatbuffers.Builder, spatialStructureOffset: flatbuffers.Offset): void;
    static addAlignments(builder: flatbuffers.Builder, alignmentsOffset: flatbuffers.Offset): void;
    static createAlignmentsVector(builder: flatbuffers.Builder, data: flatbuffers.Offset[]): flatbuffers.Offset;
    static startAlignmentsVector(builder: flatbuffers.Builder, numElems: number): void;
    static addGeometries(builder: flatbuffers.Builder, geometriesOffset: flatbuffers.Offset): void;
    static endModel(builder: flatbuffers.Builder): flatbuffers.Offset;
    static finishModelBuffer(builder: flatbuffers.Builder, offset: flatbuffers.Offset): void;
    static finishSizePrefixedModelBuffer(builder: flatbuffers.Builder, offset: flatbuffers.Offset): void;
}

/**
 * Interface representing a map of model IDs to their corresponding local IDs.
 */
export declare interface ModelIdMap {
    [key: string]: number[] | undefined;
}

export declare enum MultiThreadingRequestClass {
    CREATE_MODEL = 0,
    DELETE_MODEL = 1,
    EXECUTE = 2,
    RAYCAST = 3,
    FETCH_BOXES = 4,
    REFRESH_VIEW = 5,
    RECOMPUTE_MESHES = 6,
    CREATE_MATERIAL = 7,
    THROW_ERROR = 8
}

export declare enum ObjectClass {
    LINE = 0,
    SHELL = 1
}

/**
 * Interface representing the data for a raycast operation.
 */
export declare interface RaycastData {
    /** The camera used for the raycast */
    camera: THREE.PerspectiveCamera | THREE.OrthographicCamera;
    /** The mouse position */
    mouse: THREE.Vector2;
    /** The DOM element where the scene is rendered */
    dom: HTMLCanvasElement;
}

/**
 * Interface representing the result of a raycast operation.
 */
export declare interface RaycastResult {
    /** The local ID of the item */
    localId: number;
    /** The item ID */
    itemId: number;
    /** The point of the raycast */
    point: THREE.Vector3;
    /** The normal of the raycast */
    normal?: THREE.Vector3;
    /** The distance of the raycast */
    distance: number;
    /** The distance of the raycast from the ray origin */
    rayDistance?: number;
    /** The object that was hit */
    object: THREE.Object3D;
    /** The Fragments model that was hit */
    fragments: FragmentsModel;
    /** The ray used for the raycast */
    ray?: THREE.Ray;
    /** The frustum used for the raycast */
    frustum: THREE.Frustum;
    /** The representation class of the raycast */
    representationClass: RepresentationClass;
    /** The snapping class of the raycast */
    snappingClass: SnappingClass;
    /** The first edge of the snapped edge */
    snappedEdgeP1?: THREE.Vector3;
    /** The second edge of the snapped edge */
    snappedEdgeP2?: THREE.Vector3;
}

/**
 * Interface representing the data for a rectangle raycast operation.
 */
export declare interface RectangleRaycastData {
    /** The camera used for the raycast */
    camera: THREE.PerspectiveCamera | THREE.OrthographicCamera;
    /** The DOM element where the scene is rendered */
    dom: HTMLCanvasElement;
    /** The top left corner of the rectangle */
    topLeft: THREE.Vector2;
    /** The bottom right corner of the rectangle */
    bottomRight: THREE.Vector2;
    /** Whether the rectangle is fully included in the view */
    fullyIncluded: boolean;
}

/**
 * Interface representing the result of a rectangle raycast operation.
 */
export declare interface RectangleRaycastResult {
    /** The local IDs of the items */
    localIds: number[];
    /** The Fragments model that was hit */
    fragments: FragmentsModel;
}

export declare class Relation {
    bb: flatbuffers.ByteBuffer | null;
    bb_pos: number;
    __init(i: number, bb: flatbuffers.ByteBuffer): Relation;
    static getRootAsRelation(bb: flatbuffers.ByteBuffer, obj?: Relation): Relation;
    static getSizePrefixedRootAsRelation(bb: flatbuffers.ByteBuffer, obj?: Relation): Relation;
    data(index: number): string;
    data(index: number, optionalEncoding: flatbuffers.Encoding): string | Uint8Array;
    dataLength(): number;
    static startRelation(builder: flatbuffers.Builder): void;
    static addData(builder: flatbuffers.Builder, dataOffset: flatbuffers.Offset): void;
    static createDataVector(builder: flatbuffers.Builder, data: flatbuffers.Offset[]): flatbuffers.Offset;
    static startDataVector(builder: flatbuffers.Builder, numElems: number): void;
    static endRelation(builder: flatbuffers.Builder): flatbuffers.Offset;
    static createRelation(builder: flatbuffers.Builder, dataOffset: flatbuffers.Offset): flatbuffers.Offset;
}

/**
 * Union type representing all possible relation change types.
 */
export declare type RelsChange = RelsModifyChange;

/**
 * Interface representing a change event when relations are modified in a model item.
 */
export declare interface RelsModifyChange {
    /** Indicates this is a "modified" type change */
    type: "modified";
    /** Record containing the newly added relation data */
    added: Record<string, Set<number>>;
    /** Set of strings representing the deleted relation keys */
    deleted: Set<string>;
    /** Record containing the removed relation data */
    removed: Record<string, Set<number>>;
    /** Record containing the modified relation data */
    modified: Record<string, Set<number>>;
}

export declare enum RenderedFaces {
    ONE = 0,
    TWO = 1
}

export declare class Representation {
    bb: flatbuffers.ByteBuffer | null;
    bb_pos: number;
    __init(i: number, bb: flatbuffers.ByteBuffer): Representation;
    id(): number;
    mutate_id(value: number): boolean;
    bbox(obj?: BoundingBox): BoundingBox | null;
    representationClass(): RepresentationClass;
    mutate_representation_class(value: RepresentationClass): boolean;
    static sizeOf(): number;
    static createRepresentation(builder: flatbuffers.Builder, id: number, bbox_min_x: number, bbox_min_y: number, bbox_min_z: number, bbox_max_x: number, bbox_max_y: number, bbox_max_z: number, representation_class: RepresentationClass): flatbuffers.Offset;
}

export declare enum RepresentationClass {
    NONE = 0,
    SHELL = 1,
    CIRCLE_EXTRUSION = 2
}

/**
 * Manages a list of requests for the MeshManager.
 */
declare class RequestsManager {
    /**
     * List of requests.
     */
    readonly list: any[];
    /**
     * Checks if there are any pending requests.
     *
     * @returns `true` if there are pending requests, otherwise `false`.
     */
    get arePending(): boolean;
    /**
     * Callback function to be invoked when a request with `TileRequestClass.FINISH` is added.
     */
    onFinish: () => void;
    handleRequest(meshes: MeshManager, request: any): Promise<void>;
    /**
     * Adds an array of requests to the list. If a request with `TileRequestClass.FINISH` is added,
     * the `onFinishRequest` callback is invoked.
     *
     * @param requests - Array of requests to be added.
     */
    add(requests: any[]): void;
    /**
     * Cleans the list by removing requests with the specified model ID and `TileRequestClass.FINISH`.
     *
     * @param modelID - The model ID to filter requests by.
     */
    clean(modelID: string): void;
    /**
     * Inserts a request into the list based on its `tileRequestClass`.
     *
     * @param request - The request to be inserted.
     * @returns `true` if the request was successfully inserted, otherwise `false`.
     */
    insert(request: any): boolean;
}

/**
 * Union type representing all possible result input types.
 */
export declare type ResultInputType<T extends ItemInformationType> = T extends keyof MappedResultInput ? MappedResultInput[T] : never;

export { Sample }

/**
 * Union type representing all possible selection input types.
 */
export declare type SelectionInputType<T extends ItemSelectionType> = T extends keyof MappedSelectionInput ? MappedSelectionInput[T] : never;

/**
 * Serializer class for handling the serialization and deserialization of 3D model data. It uses the [flatbuffers library](https://flatbuffers.dev/) for efficient data serialization and deserialization.
 */
export declare class Serializer implements FragmentParser {
    parsers: FragmentParser[];
    /** {@link FragmentParser.version} */
    version: number | "auto";
    /** {@link FragmentParser.import} */
    import(bytes: Uint8Array): FragmentsGroup;
    /** {@link FragmentParser.export} */
    export(group: FragmentsGroup): Uint8Array;
    private checkCurrentVersionValid;
    private warnVersion;
}

export declare class Shell {
    bb: flatbuffers.ByteBuffer | null;
    bb_pos: number;
    __init(i: number, bb: flatbuffers.ByteBuffer): Shell;
    static getRootAsShell(bb: flatbuffers.ByteBuffer, obj?: Shell): Shell;
    static getSizePrefixedRootAsShell(bb: flatbuffers.ByteBuffer, obj?: Shell): Shell;
    profiles(index: number, obj?: ShellProfile): ShellProfile | null;
    profilesLength(): number;
    holes(index: number, obj?: ShellHole): ShellHole | null;
    holesLength(): number;
    points(index: number, obj?: FloatVector): FloatVector | null;
    pointsLength(): number;
    static startShell(builder: flatbuffers.Builder): void;
    static addProfiles(builder: flatbuffers.Builder, profilesOffset: flatbuffers.Offset): void;
    static createProfilesVector(builder: flatbuffers.Builder, data: flatbuffers.Offset[]): flatbuffers.Offset;
    static startProfilesVector(builder: flatbuffers.Builder, numElems: number): void;
    static addHoles(builder: flatbuffers.Builder, holesOffset: flatbuffers.Offset): void;
    static createHolesVector(builder: flatbuffers.Builder, data: flatbuffers.Offset[]): flatbuffers.Offset;
    static startHolesVector(builder: flatbuffers.Builder, numElems: number): void;
    static addPoints(builder: flatbuffers.Builder, pointsOffset: flatbuffers.Offset): void;
    static startPointsVector(builder: flatbuffers.Builder, numElems: number): void;
    static endShell(builder: flatbuffers.Builder): flatbuffers.Offset;
    static createShell(builder: flatbuffers.Builder, profilesOffset: flatbuffers.Offset, holesOffset: flatbuffers.Offset, pointsOffset: flatbuffers.Offset): flatbuffers.Offset;
}

export declare class ShellHole {
    bb: flatbuffers.ByteBuffer | null;
    bb_pos: number;
    __init(i: number, bb: flatbuffers.ByteBuffer): ShellHole;
    static getRootAsShellHole(bb: flatbuffers.ByteBuffer, obj?: ShellHole): ShellHole;
    static getSizePrefixedRootAsShellHole(bb: flatbuffers.ByteBuffer, obj?: ShellHole): ShellHole;
    indices(index: number): number | null;
    indicesLength(): number;
    indicesArray(): Uint16Array | null;
    profileId(): number;
    mutate_profile_id(value: number): boolean;
    static startShellHole(builder: flatbuffers.Builder): void;
    static addIndices(builder: flatbuffers.Builder, indicesOffset: flatbuffers.Offset): void;
    static createIndicesVector(builder: flatbuffers.Builder, data: number[] | Uint16Array): flatbuffers.Offset;
    /**
     * @deprecated This Uint8Array overload will be removed in the future.
     */
    static createIndicesVector(builder: flatbuffers.Builder, data: number[] | Uint8Array): flatbuffers.Offset;
    static startIndicesVector(builder: flatbuffers.Builder, numElems: number): void;
    static addProfileId(builder: flatbuffers.Builder, profileId: number): void;
    static endShellHole(builder: flatbuffers.Builder): flatbuffers.Offset;
    static createShellHole(builder: flatbuffers.Builder, indicesOffset: flatbuffers.Offset, profileId: number): flatbuffers.Offset;
}

export declare class ShellProfile {
    bb: flatbuffers.ByteBuffer | null;
    bb_pos: number;
    __init(i: number, bb: flatbuffers.ByteBuffer): ShellProfile;
    static getRootAsShellProfile(bb: flatbuffers.ByteBuffer, obj?: ShellProfile): ShellProfile;
    static getSizePrefixedRootAsShellProfile(bb: flatbuffers.ByteBuffer, obj?: ShellProfile): ShellProfile;
    indices(index: number): number | null;
    indicesLength(): number;
    indicesArray(): Uint16Array | null;
    static startShellProfile(builder: flatbuffers.Builder): void;
    static addIndices(builder: flatbuffers.Builder, indicesOffset: flatbuffers.Offset): void;
    static createIndicesVector(builder: flatbuffers.Builder, data: number[] | Uint16Array): flatbuffers.Offset;
    /**
     * @deprecated This Uint8Array overload will be removed in the future.
     */
    static createIndicesVector(builder: flatbuffers.Builder, data: number[] | Uint8Array): flatbuffers.Offset;
    static startIndicesVector(builder: flatbuffers.Builder, numElems: number): void;
    static endShellProfile(builder: flatbuffers.Builder): flatbuffers.Offset;
    static createShellProfile(builder: flatbuffers.Builder, indicesOffset: flatbuffers.Offset): flatbuffers.Offset;
}

/**
 * Enum representing the snapping class for a raycast operation.
 */
export declare enum SnappingClass {
    /** Represents a point snapping class */
    POINT = 0,
    /** Represents a line snapping class */
    LINE = 1,
    /** Represents a face snapping class */
    FACE = 2
}

export declare interface SnappingRaycastData extends RaycastData {
    snappingClasses: SnappingClass[];
}

export declare class SpatialStructure {
    bb: flatbuffers.ByteBuffer | null;
    bb_pos: number;
    __init(i: number, bb: flatbuffers.ByteBuffer): SpatialStructure;
    static getRootAsSpatialStructure(bb: flatbuffers.ByteBuffer, obj?: SpatialStructure): SpatialStructure;
    static getSizePrefixedRootAsSpatialStructure(bb: flatbuffers.ByteBuffer, obj?: SpatialStructure): SpatialStructure;
    localId(): number | null;
    mutate_local_id(value: number): boolean;
    category(): string | null;
    category(optionalEncoding: flatbuffers.Encoding): string | Uint8Array | null;
    children(index: number, obj?: SpatialStructure): SpatialStructure | null;
    childrenLength(): number;
    static startSpatialStructure(builder: flatbuffers.Builder): void;
    static addLocalId(builder: flatbuffers.Builder, localId: number): void;
    static addCategory(builder: flatbuffers.Builder, categoryOffset: flatbuffers.Offset): void;
    static addChildren(builder: flatbuffers.Builder, childrenOffset: flatbuffers.Offset): void;
    static createChildrenVector(builder: flatbuffers.Builder, data: flatbuffers.Offset[]): flatbuffers.Offset;
    static startChildrenVector(builder: flatbuffers.Builder, numElems: number): void;
    static endSpatialStructure(builder: flatbuffers.Builder): flatbuffers.Offset;
    static createSpatialStructure(builder: flatbuffers.Builder, localId: number | null, categoryOffset: flatbuffers.Offset, childrenOffset: flatbuffers.Offset): flatbuffers.Offset;
}

/**
 * Interface representing an item in a spatial tree.
 */
export declare interface SpatialTreeItem {
    /** The category of the item */
    category: string | null;
    /** The local ID of the item */
    localId: number | null;
    /** The children of the item */
    children?: SpatialTreeItem[];
}

export declare type StreamedGeometries = Map<number, {
    position: Float32Array;
    normal: Float32Array;
    index: Uint32Array;
}>;

export declare class StreamerFileDb {
    baseDirectory: string;
    maxDeadTime: number;
    mode: "buffer" | "text";
    private _memoryCleanTime;
    get memoryCleanTime(): number;
    set memoryCleanTime(value: number);
    private _intervalID;
    private _isCleaningMemory;
    constructor(baseDirectory: string);
    isCached(name: string): boolean;
    get(name: string): Promise<File | null>;
    add(name: string, buffer: Uint8Array): Promise<void>;
    clear(): Promise<void>;
    dispose(): void;
    private setupMemoryCleanup;
    private cleanMemory;
    private getDir;
    private encodeName;
    private updateLastAccessTime;
}

/**
 * A class for serializing and deserializing geometry data in a streamed format.
 */
export declare class StreamSerializer {
    /**
     * Imports geometry data from a byte array in a streamed format.
     *
     * @param bytes - The byte array containing the serialized geometry data.
     * @returns A Map of geometry IDs to their respective position, normal, and index arrays.
     * @throws Will throw an error if the geometry ID is not found.
     */
    import(bytes: Uint8Array): StreamedGeometries;
    /**
     * Exports geometry data to a byte array in a streamed format.
     *
     * @param geometries - A Map of geometry IDs to their respective position, normal, and index arrays.
     * @returns A Uint8Array containing the serialized geometry data.
     */
    export(geometries: StreamedGeometries): Uint8Array;
}

export declare enum Stroke {
    DEFAULT = 0
}

declare type ThreadHandler = (args: any) => Promise<void> | void;

export declare enum TileRequestClass {
    UPDATE = 0,
    CREATE = 1,
    DELETE = 2,
    FINISH = 3
}

export declare class Transform {
    bb: flatbuffers.ByteBuffer | null;
    bb_pos: number;
    __init(i: number, bb: flatbuffers.ByteBuffer): Transform;
    position(obj?: DoubleVector): DoubleVector | null;
    xDirection(obj?: FloatVector): FloatVector | null;
    yDirection(obj?: FloatVector): FloatVector | null;
    static sizeOf(): number;
    static createTransform(builder: flatbuffers.Builder, position_x: number, position_y: number, position_z: number, x_direction_x: number, x_direction_y: number, x_direction_z: number, y_direction_x: number, y_direction_y: number, y_direction_z: number): flatbuffers.Offset;
}

/**
 * Interface representing the configuration for a virtual model.
 */
export declare interface VirtualModelConfig {
    /** Optional properties configuration for the virtual model */
    properties?: VirtualPropertiesConfig;
}

/**
 * Interface representing the configuration for virtual properties in a Fragments model.
 */
export declare interface VirtualPropertiesConfig {
    /** An array of extra relations to include in the virtual model */
    extraRelations?: {
        category: string;
        relation: string;
        inverseName: string;
    }[];
}

export declare class Wire {
    bb: flatbuffers.ByteBuffer | null;
    bb_pos: number;
    __init(i: number, bb: flatbuffers.ByteBuffer): Wire;
    p1(obj?: FloatVector): FloatVector | null;
    p2(obj?: FloatVector): FloatVector | null;
    static sizeOf(): number;
    static createWire(builder: flatbuffers.Builder, p1_x: number, p1_y: number, p1_z: number, p2_x: number, p2_y: number, p2_z: number): flatbuffers.Offset;
}

export declare class WireSet {
    bb: flatbuffers.ByteBuffer | null;
    bb_pos: number;
    __init(i: number, bb: flatbuffers.ByteBuffer): WireSet;
    static getRootAsWireSet(bb: flatbuffers.ByteBuffer, obj?: WireSet): WireSet;
    static getSizePrefixedRootAsWireSet(bb: flatbuffers.ByteBuffer, obj?: WireSet): WireSet;
    ps(index: number, obj?: FloatVector): FloatVector | null;
    psLength(): number;
    static startWireSet(builder: flatbuffers.Builder): void;
    static addPs(builder: flatbuffers.Builder, psOffset: flatbuffers.Offset): void;
    static startPsVector(builder: flatbuffers.Builder, numElems: number): void;
    static endWireSet(builder: flatbuffers.Builder): flatbuffers.Offset;
    static createWireSet(builder: flatbuffers.Builder, psOffset: flatbuffers.Offset): flatbuffers.Offset;
}

export { }
